import json
import uuid

from django.db import models
from django.forms import ValidationError
from django.utils.translation import ugettext_lazy as _
import ast

class AbstractBaseModel(models.Model):
    """
    Base abstract model, that has `uuid` instead of `id` and includes `created_at`, `updated_at` fields.
    """
    uuid = models.UUIDField(_('Internal UUID'), primary_key=True, default=uuid.uuid4, editable=False, unique=True, help_text=_('Autogenerated UUID.'))
    created_at = models.DateTimeField(_('Created at'), auto_now_add=True, editable=False, help_text=_('Timestamp automatically generated upon creation of the object.'))
    updated_at = models.DateTimeField(_('Updated at'), auto_now=True, editable=True, help_text=_('Automatically updated to the last modification timestamp.'))
    _version = models.CharField(max_length=255, help_text=_('Datatstore version used in mutations'), null=True, blank=True)
    class Meta:
        abstract = True
        ordering = ['updated_at']

    # def __repr__(self):  #     return f'<{self.__class__.__name__} {self.uuid}>'

# class CustomField(models.Model):
#     uuid = models.UUIDField(_('Internal UUID'), primary_key=True, default=uuid.uuid4, editable=False, unique=True, help_text=_('Autogenerated UUID.'))
#     key = models.SlugField(_('Key'), unique=False, db_index=False, help_text=_('The name for your custom field.'))
#     value = models.CharField(_('Value'), max_length=4096, blank=True, help_text=_('The content of your custom field.'))
#     content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE, editable=False)
#     object_id = models.UUIDField(editable=False)
#     content_object = GenericForeignKey('content_type', 'object_id')
#
#     def __str__(self):
#         return self.key
#
#     class Meta:
#         verbose_name = _('Custom Field')
#         verbose_name_plural = _('Custom Fields')
#         ordering = ['object_id']

class JSONWrappedTextField(models.TextField):
    def to_python(self, value):
        if isinstance(value, str): #changed this line
            if not value:
                value = "{}"
            try:
                value = super(JSONWrappedTextField, self).to_python(value)
                value = ast.literal_eval(value)
            except Exception as e:
                print("Exception ", e)
                raise ValidationError("This is not a valid JSON!")
        return value

    def get_db_prep_value(self, value, connection, prepared=False):
        value = super(JSONWrappedTextField, self).get_db_prep_value(value, connection, prepared)
        print('helllo')
        if isinstance(value, dict):
            value = json.dumps(value)

        return value
        
class GlobalTransactionStatus(models.TextChoices):
    
    new = 'NEW', _('New')
    fundtransaction_in_progress = 'FUNDTRANSACTION_IN_PROGRESS', _('Fund transaction in progress')
    collectransaction_in_progress = 'COLLECTTRANSACTION_IN_PROGRESS', _('Collect transaction in progress')
    refunded = 'REFUNDED', _('Transaction refunded')
    refundtransaction_in_progress = 'REFUNDTRANSACTION_IN_PROGRESS', _('Refund transaction in progress')
    success = 'SUCCESS', _('Transaction completed successfully')
    canceled = 'CANCELLED', _('Transaction cancelled')
    blocked = 'BLOCKED', _('Collect transactions blocked')
    funding_error = 'FUNDING_ERROR', _('Funding transaction error')
    not_found = 'NOT_FOUND', _('Transaction not found') # what ? related to collect transaction status
    refunded_error = 'REFUNDED_ERROR', _('Refund Error')


class CollectTransactionStatus(models.TextChoices):
    
    new = 'NEW', _('New')
    collected = 'SUCCESS', _('Transaction successfully collected')
    aml_blocked = 'AML_BLOCKED', _('Money laundering suspected !')
    blocked = 'BLOCKED', _('Transaction blocked')
    not_found = 'NOT_FOUND', _('Transaction not found')
    canceled = 'CANCELLED', _('Transaction cancelled')
    error = 'ERROR', _('Transaction error')
    on_hold = 'ON_HOLD', _('Transaction on hold')
    in_progress = 'IN_PROGRESS', _('Transaction in progress')
    #refunded = 'REFUNDED', _('Transaction refunded')
    rejected = "REJECTED", _('Transaction rejected ')
    collect_ready = "COLLECT_READY", _('Transaction ready to be collected')


class FundingTransactionStatus(models.TextChoices):

    new = 'NEW', _('New')
    in_progress = 'IN_PROGRESS', _('Transaction in progress')
    auth_error = 'AUTH_ERROR', _('Authorization error')
    complete_error = 'COMPLETE_ERROR', _('Completion error')
    error = 'ERROR', _('Transaction error')
    refunded = 'REFUNDED', _('Transaction refunded')
    success = 'SUCCESS', _('Transaction successful')


class PartnerStatus(models.TextChoices):
    active = 'ACTIVE', _('Active')
    inactive = 'INACTIVE', _('Inactive')
    failed = 'FAILED', _('Failed')
    disabled = 'DISABLED', _('Disabled')


class TransactionTypes(models.TextChoices):
    funding = 'FUNDING', _('Funding')
    collect = 'COLLECT', _('Collect')


class PartnerType(models.TextChoices):
    funding = TransactionTypes.choices[0]
    collect = TransactionTypes.choices[1]
    kyc_verification = 'KYC VERIFICATION', _('KYC Verification')
    bank_verification = 'BANK VERIFICATION', _('Bank Verification')
    conversion = 'CONVERSION', _('Conversion')
    


class OperationLogStatus(models.TextChoices):
    new = 'NEW', _('New')
    started = 'IN_PROGRESS', _('Operation in progress')
    reverted = 'CANCELLED', _('Operation cancelled')
    failed = 'FAILED', _('Operation failed')
    completed = 'COMPLETED', _('Operation succesful')

class VerificationStatus(models.TextChoices):
    unverified = 'NOT_VERIFIED', _('Not Verified')
    verified = 'VERIFIED', _('Verified')
